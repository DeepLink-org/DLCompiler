#ifndef LinalgEXT_PASSES
#define LinalgEXT_PASSES

include "mlir/Pass/PassBase.td"

def LinalgIfToSelect : Pass<"linalg-if-to-select", "mlir::ModuleOp"> {
  let summary = "Convert scf.if inside parallel linalg.generic to arith.select and hoist selects.";
  let description = [{
    This pass converts conditional logic (`scf.if`) inside a parallel `linalg.generic`
    operation into data-flow operations (`arith.select`).

    The conversion process involves two main stages:
    1.  **LinalgIfToSelectPattern**: Converts `scf.if` statements (where the else
        block yields a constant or is empty) into an equivalent sequence of
        `arith.select` operations. For arguments used inside the `then` block,
        it introduces an `arith.select` using a zero constant for the false case.
        It also attempts to fix zero-value assignment for `memref.store` operations
        that result from the conversion (FixLinalgSelectZeroForStorePattern).
    2.  **LinalgLiftSelectPattern**: Lifts scalar `arith.select` operations that use
        loop-invariant operands or block arguments outside the `linalg.generic`
        operation, converting them into tensor-based `arith.select`s which are
        then added as new inputs to the `linalg.generic`. This process helps to
        simplify the body of the `linalg.generic` and enables further fusion.
  }];
  let constructor = "mlir::dicp::LinalgExt::createLinalgIfToSelectPass()";
  let dependentDialects = ["mlir::linalg::LinalgDialect",
                           "mlir::arith::ArithDialect",
                           "mlir::tensor::TensorDialect",
                           "mlir::scf::SCFDialect",
                           "mlir::memref::MemRefDialect"]; 
}


def LinalgGenericToSCF : Pass<"linalg-generic-to-scf", "mlir::ModuleOp"> {
  let summary = "Lower linalg.generic ops to SCF loops";
  let description = [{
    Converts linalg.generic operations into explicit scf.for loops,
    generating structured loop nests that preserve the original
    indexing maps and iterator types.
  }];
  let constructor = "mlir::dicp::LinalgExt::createLinalgGenericToSCFPass()";
  let dependentDialects = ["mlir::linalg::LinalgDialect"];
}


def ScalarTo1DTensor : Pass<"scalar-to-1d-tensor", "mlir::func::FuncOp"> {
  let summary = "Convert scalar computations and memref load/store to tensor<1 x T> form";
  let description = [{
    The ScalarTo1DTensor pass targets scalar computations and
    memory access within a function and rewrites them into an explicit
    tensor<1 x T>-based form. This enables uniform handling of scalar
    values in subsequent bufferization and lowering passes.
  }];
  
  let constructor = "mlir::dicp::LinalgExt::createScalarTo1DTensorPass()";
  let dependentDialects = [
    "mlir::arith::ArithDialect",
    "mlir::memref::MemRefDialect",
    "mlir::tensor::TensorDialect",
    "mlir::bufferization::BufferizationDialect",
    "mlir::func::FuncDialect"
  ];
}

def NormalizeSliceOps : Pass<"normalize-slice-ops", "func::FuncOp"> {
  let summary = "Normalize Slice Ops.";
  let constructor = "mlir::dicp::LinalgExt::createNormalizeSliceOpsPass()";
  let dependentDialects = ["mlir::tensor::TensorDialect"];
}

def NPUUnroolPipeline : Pass<"npu-unrool-pipeline", "func::FuncOp"> {
  let summary = "DLC Pipelines.";
  let constructor = "mlir::dicp::LinalgExt::createNPUUnroolPipelinePass()";
  let dependentDialects = [
    "mlir::arith::ArithDialect",
    "mlir::memref::MemRefDialect",
    "mlir::tensor::TensorDialect",
    "mlir::bufferization::BufferizationDialect",
    "mlir::func::FuncDialect"
    ];
}


def NPUVectorTileTagging : Pass<"npu-tile-loop-tagging", "ModuleOp"> {
  let summary = "Normalize and tag operations for NPU tiling and fusion";
  let description = [{
    This pass performs IR normalization (elementwise to generic, copy lowering) 
    and analyzes stages to identify tiling anchors and fusion candidates.
    It marks operations with attributes to guide the subsequent transform pass.
  }];
  let constructor = "mlir::dicp::LinalgExt::createNPUVectorTileTaggingPass()";
  let options = [
    Option<"tiledMixVectorLoopNumber", "vector-tile", "unsigned",
           /*default=*/"2", "Trip count for vector loop tiling">
  ];
  let dependentDialects = [
    "mlir::linalg::LinalgDialect",
    "mlir::tensor::TensorDialect",
    "mlir::memref::MemRefDialect",
    "mlir::bufferization::BufferizationDialect",
    "mlir::scf::SCFDialect"
  ];
}

def NPUVectorTileTransform : Pass<"npu-tile-loop-transform", "ModuleOp"> {
  let summary = "Apply tiling and fusion using Transform Dialect based on tags";
  let description = [{
    This pass reads the tags generated by the tagging pass and executes a 
    Transform Dialect sequence to perform the actual tiling and fusion.
  }];
  let constructor = "mlir::dicp::LinalgExt::createNPUVectorTileTransformPass()";
  let dependentDialects = [
    "mlir::transform::TransformDialect",
    "mlir::linalg::LinalgDialect",
    "mlir::scf::SCFDialect"
  ];
}

def DeLinalgize : Pass<"de-linalgize", "mlir::ModuleOp"> {
  let summary = "De-linalgize Linalg operations back to specific dialects.";
  let description = [{
    This pass restores high-level operations from their `linalg` representations:
    1. Converts `linalg.generic` back to elementwise operations (e.g., `arith` or `math`).
    2. Converts `linalg.copy` back to `bufferization.materialize_in_destination` 
       or `memref.copy`.
    It is essentially the inverse of normalization/generalization passes.
  }];

  let constructor = "mlir::dicp::LinalgExt::createDeLinalgizePass()";
  
  let dependentDialects = [
    "mlir::arith::ArithDialect",
    "mlir::math::MathDialect",
    "mlir::memref::MemRefDialect",
    "mlir::bufferization::BufferizationDialect",
    "mlir::linalg::LinalgDialect"
  ];
}

def FuseLoop : Pass<"fuse-loop", "mlir::ModuleOp"> {
  let summary = "Fuse cube and vector loops";
  let constructor = "mlir::dicp::LinalgExt::createFuseLoopPass()";
  let dependentDialects = ["mlir::transform::TransformDialect"];
}

def LoopUnrollStage : Pass<"dicp-loop-unroll-stage", "mlir::func::FuncOp"> {
  let summary = "Unroll loops containing operations marked with DICP stage attributes.";
  let description = [{
    This pass identifies `scf.for` loops that contain operations with a specific 
    DICP stage prefix and performs full unrolling when constant bounds are available.
    After processing, it cleans up the internal stage attributes.
  }];
  let constructor = "mlir::dicp::LinalgExt::createLoopUnrollStagePass()";
  let dependentDialects = [
    "mlir::scf::SCFDialect",
    "mlir::func::FuncDialect"
  ];
}

def ShrinkBuffers : Pass<"shrink-buffers", "mlir::func::FuncOp"> {
  let summary = "Shrink memref.alloc and tensor.empty based on consistent slicing usage.";
  let description = [{
    Runs two rewrite patterns (ShrinkAllocWithSlicing and ShrinkEmptyTensorWithSlicing)
    to reduce allocation/empty sizes when all slices agree on a smaller size.
  }];
  let constructor = "mlir::dicp::LinalgExt::createShrinkBuffersPass()";
}

#endif
