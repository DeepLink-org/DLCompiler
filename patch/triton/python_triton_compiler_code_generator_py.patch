diff --git a/python/triton/compiler/code_generator.py b/python/triton/compiler/code_generator.py
index d8ca58d8d..f68ce59ad 100644
--- a/python/triton/compiler/code_generator.py
+++ b/python/triton/compiler/code_generator.py
@@ -15,6 +15,9 @@ from ..runtime.jit import _normalize_ty, get_jit_fn_file_line
 from ..runtime import JITFunction
 from .errors import (CompilationError, CompileTimeAssertionFailure, UnsupportedLanguageConstruct)
 from types import ModuleType
+import logging
+
+logging = logging.getLogger(__name__)
 
 
 def mangle_ty(ty):
@@ -383,6 +386,39 @@ class CodeGenerator(ast.NodeVisitor):
         post_ret_block = self.builder.create_block()
         self.builder.set_insertion_point_to_end(post_ret_block)
 
+    def visit_Lambda(self, node):
+        # 1. get lambda argument names
+        arg_names = [arg.arg for arg in node.args.args]
+
+        # 2. collect lambda closure variables
+        class ClosureCollector(ast.NodeVisitor):
+            def __init__(self):
+                self.vars = set()
+
+            def visit_Name(self, node):
+                if isinstance(node.ctx, ast.Load):
+                    self.vars.add(node.id)
+                self.generic_visit(node)
+
+        collector = ClosureCollector()
+        collector.visit(node.body)
+
+        # 3. get closure variables
+        closure_vars = {}
+        closure_names = []
+        for var_name in collector.vars:
+            if var_name in self.lscope and var_name not in arg_names:
+                closure_vars[var_name] = self.lscope[var_name]
+                closure_names.append(var_name)
+
+        # 4. create inline_lambda object
+        return language.extra.deeplink.inline_lambda(
+            node=node,
+            closure_values=list(closure_vars.values()),
+            closure_names=closure_names,
+            arg_names=arg_names
+        )
+
     def visit_FunctionDef(self, node):
         arg_names, kwarg_names = self.visit(node.args)
         if self.fn:
@@ -486,6 +522,7 @@ class CodeGenerator(ast.NodeVisitor):
         return self.visit_Assign(node)
 
     def visit_Assign(self, node):
+        # logging.error(f"Visiting Assign node: {ast.dump(node, indent=4)}")
         _names = []
         if isinstance(node, ast.AnnAssign):
             _names += [self.visit(node.target)]
@@ -910,7 +947,8 @@ class CodeGenerator(ast.NodeVisitor):
             return
         num_stages = None
         loop_unroll_factor = None
-        if IteratorClass is language.range:
+        bind_sub_block = None
+        if IteratorClass in [language.range, language.extra.deeplink.parallel]:
             iterator = IteratorClass(*iter_args, **iter_kwargs)
             # visit iterator arguments
             # note: only `range` iterator is supported now
@@ -920,6 +958,8 @@ class CodeGenerator(ast.NodeVisitor):
             step = iterator.step
             num_stages = iterator.num_stages
             loop_unroll_factor = iterator.loop_unroll_factor
+            if (IteratorClass is language.extra.deeplink.parallel):
+                bind_sub_block = iterator.bind_sub_block
         elif IteratorClass is range:
             # visit iterator arguments
             # note: only `range` iterator is supported now
@@ -992,6 +1032,8 @@ class CodeGenerator(ast.NodeVisitor):
                 for_op.set_attr("tt.num_stages", self.builder.get_int32_attr(num_stages))
             if loop_unroll_factor is not None:
                 for_op.set_attr("tt.loop_unroll_factor", self.builder.get_int32_attr(loop_unroll_factor))
+            if (bind_sub_block is not None) and bind_sub_block:
+                for_op.set_attr("bind_sub_block", self.builder.get_bool_attr(bind_sub_block))
 
             self.scf_stack.append(node)
             self.builder.set_insertion_point_to_start(for_op.get_body(0))
@@ -1096,6 +1138,13 @@ class CodeGenerator(ast.NodeVisitor):
 
     def visit_Call(self, node):
         fn = _unwrap_if_constexpr(self.visit(node.func))
+
+        if isinstance(fn, language.extra.deeplink.inline_lambda):
+            # get the arguments
+            args = [self.visit(arg) for arg in node.args]
+            # call the lambda function
+            return fn(*args, generator=self)
+
         static_implementation = self.statically_implemented_functions.get(fn)
         if static_implementation is not None:
             return static_implementation(self, node)
