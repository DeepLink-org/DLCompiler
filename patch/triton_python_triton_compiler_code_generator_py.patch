diff --git a/python/triton/compiler/code_generator.py b/python/triton/compiler/code_generator.py
index d8ca58d8d..84d724d7f 100644
--- a/python/triton/compiler/code_generator.py
+++ b/python/triton/compiler/code_generator.py
@@ -15,6 +15,10 @@ from ..runtime.jit import _normalize_ty, get_jit_fn_file_line
 from ..runtime import JITFunction
 from .errors import (CompilationError, CompileTimeAssertionFailure, UnsupportedLanguageConstruct)
 from types import ModuleType
+import logging
+
+logging = logging.getLogger(__name__)
+# logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
 
 
 def mangle_ty(ty):
@@ -349,6 +353,7 @@ class CodeGenerator(ast.NodeVisitor):
                 break
 
     def visit_Module(self, node):
+        # logging.error(f"Visiting Module node: {ast.dump(node, indent=4)}")
         ast.NodeVisitor.generic_visit(self, node)
 
     def visit_List(self, node):
@@ -383,6 +388,40 @@ class CodeGenerator(ast.NodeVisitor):
         post_ret_block = self.builder.create_block()
         self.builder.set_insertion_point_to_end(post_ret_block)
 
+
+    def visit_Lambda(self, node):
+        # 1. 提取参数名
+        arg_names = [arg.arg for arg in node.args.args]
+        
+        # 2. 识别闭包变量
+        class ClosureCollector(ast.NodeVisitor):
+            def __init__(self):
+                self.vars = set()
+            
+            def visit_Name(self, node):
+                if isinstance(node.ctx, ast.Load):
+                    self.vars.add(node.id)
+                self.generic_visit(node)
+        
+        collector = ClosureCollector()
+        collector.visit(node.body)
+        
+        # 从当前作用域中筛选闭包变量
+        closure_vars = {}
+        closure_names = []
+        for var_name in collector.vars:
+            if var_name in self.lscope and var_name not in arg_names:
+                closure_vars[var_name] = self.lscope[var_name]
+                closure_names.append(var_name)
+        
+        # 3. 返回可内联的lambda对象
+        return language.extra.deeplink.InlineLambda(
+            node=node,
+            closure_values=list(closure_vars.values()),
+            closure_names=closure_names,
+            arg_names=arg_names
+        )
+
     def visit_FunctionDef(self, node):
         arg_names, kwarg_names = self.visit(node.args)
         if self.fn:
@@ -486,6 +525,7 @@ class CodeGenerator(ast.NodeVisitor):
         return self.visit_Assign(node)
 
     def visit_Assign(self, node):
+        # logging.error(f"Visiting Assign node: {ast.dump(node, indent=4)}")
         _names = []
         if isinstance(node, ast.AnnAssign):
             _names += [self.visit(node.target)]
@@ -681,6 +721,7 @@ class CodeGenerator(ast.NodeVisitor):
             self.set_value(name, new_tensor)
 
     def visit_If(self, node):
+        # logging.error(f"Visiting If node: {ast.dump(node, indent=4)}")
         cond = self.visit(node.test)
 
         if _is_triton_tensor(cond):
@@ -910,7 +951,8 @@ class CodeGenerator(ast.NodeVisitor):
             return
         num_stages = None
         loop_unroll_factor = None
-        if IteratorClass is language.range:
+        bind_sub_block = None
+        if IteratorClass in [language.range, language.extra.deeplink.parallel]:
             iterator = IteratorClass(*iter_args, **iter_kwargs)
             # visit iterator arguments
             # note: only `range` iterator is supported now
@@ -920,6 +962,8 @@ class CodeGenerator(ast.NodeVisitor):
             step = iterator.step
             num_stages = iterator.num_stages
             loop_unroll_factor = iterator.loop_unroll_factor
+            if (IteratorClass is language.extra.deeplink.parallel):
+                bind_sub_block = iterator.bind_sub_block
         elif IteratorClass is range:
             # visit iterator arguments
             # note: only `range` iterator is supported now
@@ -992,6 +1036,8 @@ class CodeGenerator(ast.NodeVisitor):
                 for_op.set_attr("tt.num_stages", self.builder.get_int32_attr(num_stages))
             if loop_unroll_factor is not None:
                 for_op.set_attr("tt.loop_unroll_factor", self.builder.get_int32_attr(loop_unroll_factor))
+            if (bind_sub_block is not None) and bind_sub_block:
+                for_op.set_attr("bind_sub_block", self.builder.get_bool_attr(bind_sub_block))
 
             self.scf_stack.append(node)
             self.builder.set_insertion_point_to_start(for_op.get_body(0))
@@ -1095,7 +1141,16 @@ class CodeGenerator(ast.NodeVisitor):
             return tuple(results)
 
     def visit_Call(self, node):
+        # logging.error(f"Visiting Call node: {ast.dump(node, indent=4)}")
         fn = _unwrap_if_constexpr(self.visit(node.func))
+        
+        if isinstance(fn, language.extra.deeplink.InlineLambda):
+            # 获取参数
+            args = [self.visit(arg) for arg in node.args]
+            
+            # 内联执行lambda体
+            return fn(*args, generator=self)
+
         static_implementation = self.statically_implemented_functions.get(fn)
         if static_implementation is not None:
             return static_implementation(self, node)
